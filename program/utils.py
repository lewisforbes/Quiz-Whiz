# Utils used accross program
# from markdown import markdown # TODO remove. talk about in report.
import re
import base64
import os
import subprocess
from shutil import rmtree
import sys
from difflib import SequenceMatcher
# to allow `from program.utils import get_user_input` in main.py:
try:
    from colorama import Fore, init
    init()
    import pypandoc
    from tabulate import tabulate
except ModuleNotFoundError:
    pass


###############
## CONSTANTS ##
####h##h#######
FBACK_BULLETS = {"++":"correctfeedback", "~~":"partiallycorrectfeedback", "--":"incorrectfeedback"}
COMMENT = ":"
BULLET = "-"
NUMBER_PAT = "[0-9]. " # check this


#############
## STRINGS ##
#############

# input: string
# output: True iff input is None/blank/whitespace-only
def is_blank(s, space_is_blank=True):
    if not space_is_blank:
        s = s.replace(" ", "-") # - not removed by strip
    return s==None or s.strip()==""

# removes HTML tags 
def remove_tags(raw_html):
  return re.sub("<.*?>", "", raw_html)

# removes first 'word' from string  
# generally removes - / x. / #
# input_parser.verify_answers() should ensure assertions
def get_line_content(s):
    try:
        content = s.split(" ")
        assert re.match("[0-9]+\.", content[0]) or content[0] in ["-", "#"]
    except:
        not_enough_spaces(s) # ends termination

    output = ""
    for x in content[1:]:
        output += x + " "
    output = output[:-1] # remove extra space at the end
    return output

# input: string
# output: output ready to be written to file
def file_str(x):
    if x:
        return str(x)
    else:
        return ""
    
# input: string
# output: Bool/int/string where appropriate
def force_type(s):
    if s.lower() == "true":    
        return True
    if s.lower() == "false":
        return False

    try:
        return int(s)
    except:
        pass

    try:
        return float(s)
    except:
        return s # returns string
    
# converts a markdown string to an HTML string
def md_to_html(md_str):

    # input: raw markdown
    # output: markdown with newlines outside of code blocks duplicated 
    def format_not_code(md_str):
        code_is = [(m.start(), m.end()) for m in re.finditer("```(.|\n)*?```", md_str)]
        nl_to_dupe = []
        for nl_i in [m.start() for m in re.finditer("\n", md_str)]:
            dupe = True
            for code_i in code_is:
                if nl_i>=code_i[0] and nl_i<code_i[1]: # if nl_i within code block
                    dupe = False
                    break
            # nl_i is not within code block
            if dupe:
                nl_to_dupe.append(nl_i)
        for nl_i in sorted(nl_to_dupe, reverse=True):
            md_str = sub_range(md_str, "\n\n", nl_i, nl_i+1)
        return md_str
    
    # input: html generated by pandoc
    # output: html with <br> instead of \n in code blocks
    def format_code(html):
        TIMEOUT = 10000 # max loops
        # code for which user has specified language
        PATTERN = '<div class="sourceCode"(.|\n)*?<\/div>'
        match = re.search(PATTERN, html)
        i = 0
        while match and ("\n" in match.group(0)):
            match_str = re.sub("<\/span>\n<span", "</span><br><span", match.group(0)) # add code newlines
            match_str = re.sub("<pre\n", "<pre ", match_str) # remove newline in pre tag

            html = sub_range(html, match_str, match.start(), match.end())
            match = re.search(PATTERN, html)
            i+=1
            if i==TIMEOUT:
                error("Unexpected error: timeout in utils.md_to_html.format_code")
        
        # code for which user has not specified language
        PATTERN = "<pre><code>(.|\n)*?<\/code><\/pre>"
        match = re.search(PATTERN, html)
        i = 0
        while match and ("\n" in match.group(0)):
            match_str = re.sub("\n", "<br>", match.group(0))
            html = sub_range(html, match_str, match.start(), match.end())
            match = re.search(PATTERN, html)
            i+=1
            if i==TIMEOUT:
                error("Unexpected error: timeout in utils.md_to_html.format_code.")
        return html
        
    # input: html with images converted by pandoc
    # output: html with images adjusted for import
    def format_images(html):
        # input: filepath of local image
        # output: string of image encoded in base64
        def img_to_b64(fpath):
            with safe_open(fpath, "rb") as f:
                data = str(base64.b64encode(f.read()))
                return "data:image/;base64, {}".format(data.replace("'", "")[1:])

        srcs = re.findall("src=\".*?\"", html)
        for src in srcs:
            if len(re.findall("https*?://", src))==0:
                # images are local
                im_path = re.findall("\".*\"", src)[0].replace("\"", "")
                html = html.replace(src, "src=\"{}\"".format(img_to_b64(im_path)))
        # fix alt text
        alts = re.findall("<figcaption>(.*?)<\/figcaption>", html)
        for alt in alts: # skipped if no alt text
            old_re = 'alt="".*?\/><figcaption>{}<\/figcaption>'.format(alt)
            assert re.search(old_re, html) # ensure structure is as expected
            html = re.sub(old_re, 'alt="{}"/> '.format(alt), html) # move alt text to alt="", remove figcaption tag
        return html

    ## CHOOSE HOW TO CONVERT INITIAL MD ##
    if has_formatting(md_str):
        md_str = format_not_code(md_str)
        try:
            # call Pandoc directly (saves time) # TODO test on linux
            html = subprocess.check_output("pandoc -f markdown -t html -", input=md_str, 
                                           shell=True, text=True, stderr=subprocess.DEVNULL, encoding='utf-8')
        except subprocess.CalledProcessError: # pandoc command failed
            warning("utils.mypandoc failed.") # TODO remove
            html = pypandoc.convert_text(md_str, to='html', format='md')

        # assert html.count("\r")==html.count("\r\n")
        html = html.replace("\r", "") # \r pointless and ruins regex
        
    else:
        html = f"<p>{md_str}</p>".replace("\n", "</p> <p>")
    
    ## FIX FORMATTING ETC FOR IMPORTING ## 
    html = format_code(html)
    html = html.replace("\n", " ") # all remaining newlines redundant
    html = re.sub("<p> *?<\/p>", "<br>", html) # replace blank <p> tags with <br>
    html = format_images(html)
    return html

# replaces provided range in old_str with sub
def sub_range(old_str, sub_str, start, end):
    if end<start or start<0 or end>len(old_str):
        error("utils.sub_range() not being used as intended.") 
    start_str = old_str[0:start]
    end_str = old_str[end:]
    return start_str + sub_str + end_str

# returns the properties from a raw question/answer string
# format: << name1:val1; name2:val2 >>
def get_props(s):
    props_pattern = "<<((?:\n|.)*?)>>"
    props = re.findall(props_pattern, s)
    if len(props)==0 or props[0].strip()=="":
        return None

    output = {}
    for p_group in props:
        print(p_group)
        p_group = remove_blanks(p_group.replace("\n", "").split(";")) # [name1:val1, name2:val2, name3:val3]
        for p in p_group:
            n_v = [s.strip() for s in p.split(":")] # [name1, val1]
            if len(n_v)!=2:
                error(f"Property '{p}' is invalid.")
            if n_v[0] in output: # name already in output
                if output[n_v[0]]!=n_v[1]: # if current value for this name doesn't match provided
                    error(f"Property '{n_v[0]}' declared as both '{output[n_v[0]]}' and '{n_v[1]}'.")
            else:
                output[n_v[0]]=n_v[1] # set output[name] to value
    return output

# removes properties from a string
def remove_props(s):
    if s==None:
        return None
    props_pattern = "<<((?:\n|.)*?)>>"
    return re.sub(props_pattern, "", s)

# returns true iff string possibly contains markdown formatting, images or code
def has_formatting(s):
    return ("*" in s) or ("_" in s) or ("[" in s) or ("`" in s) or ("$" in s)

# makes table summarising parsed questions
def make_parse_table(quizzes):
    FILE = "File"
    TOTAL = "Total Qs"
    to_write = {FILE:[], TOTAL:[]}
    # get all qtypes
    for quiz in quizzes:
        for qtype in quiz.question_summary():
            to_write[qtype]=[]

    # find qtype counts in each quiz
    for quiz in quizzes:
        summary = quiz.question_summary()
        to_write[TOTAL].append(sum(summary.values()))
        for qtype in to_write:
            if qtype==TOTAL:
                continue
            if qtype==FILE: # not actually qtype
                if len(quiz.input_file)<=20:
                    to_write[FILE].append(quiz.input_file)
                else:
                    to_write[FILE].append(quiz.input_file[:18]+"...")                
            else:
                if qtype in summary:
                    to_write[qtype].append(summary[qtype])
                else:
                    to_write[qtype].append(0)

    # add totals column
    if len(quizzes)>1:
        to_write[FILE] += ["-", "Total"]
        for key in to_write:
            if key==FILE:
                continue
            to_write[key] += ["-",sum(to_write[key])]

    
    return tabulate(to_write, tablefmt='rounded_outline', headers="keys")

# returns the contents of logo.txt
def get_logo():
    try:
        f = open("program/logo.txt", "r")
        output = f.read()
        f.close()
        return output
    except:
        t = "- Quiz Whiz -"
        return f"{'-'*len(t)}\n{t}\n{'-'*len(t)}\n"

# https://stackoverflow.com/questions/17388213/find-the-similarity-metric-between-two-strings
# returns the filename in comps which original is most similar to. if every similarity is below threshold, None is returned.
def most_similar(original, comps, threshold=0.6):  # 0.6 follows their heuristic in the documentation
    # input verification
    if comps==[]: return None
    
    # remove extension. happens within big list comp below to preserve original filename for output
    original = original.split(".")[:-1][0] if "." in original else original
    
    # do comparisons
    ratios = [(SequenceMatcher(None, original, c.split(".")[:-1][0] if "." in c else c).ratio(), c) for c in comps] # [(ratio, comp_file)]
    
    # return max if above threshold
    m = max(ratios, key=lambda r: r[0])
    return m[1] if m[0]>=threshold else None

############
## ARRAYS ##
############

# arr: array
# space_is_blank: True iff space(s) considered blank
# output: array with blank elements removed
def remove_blanks(arr, space_is_blank=True):
    output = []
    for x in arr:
        if not is_blank(x, space_is_blank):
            output.append(x)
    return output

# input: array
# output: [array, array]
# explaination: splits on the first blank element in arr. if no blank found, returns None
def split_on_blank(arr, space_is_blank=True):
    fst = []
    snd = []
    blank_found = False
    for x in arr:
        if is_blank(x, space_is_blank) and not blank_found:
            blank_found = True
            continue # do not add first blank to any output
        
        if blank_found:
            snd.append(x)
        else:
            fst.append(x)
    return [fst, snd]

# returns the intersection of two arrays
def get_intersection(arr1, arr2):
    output = []
    for e1 in arr1:
        for e2 in arr2:
            if e1==e2:
                output.append(e1)
    return output


##############
## TERMINAL ##
##############

# prints error and terminates program
# progress always shown apart from when error is unexpected.
def error(msg, show_progress=True):
    newline = "\n> "
    progress = Progress.current_action
    if not show_progress or progress=="":
        newline = ""
    else:
        msg = msg.replace("\n", newline)

    import_file = ""
    if Progress.import_file:
        import_file = f" in '{Progress.import_file}'"
    
    print(f"\n{Fore.RED}Error{progress}{import_file}: {newline}{msg}{Fore.RESET}")
    del_tmp_dir()
    sys.exit()

# keeps track of progress/status for more descriptive errors
class Progress:
    import_file = None
    import_fpath = None # import_file = path.basepath(import_fpath)
    current_q = 0
    current_action = "" # parsing, exporting to moodle, exporting to learn
    
    warn_count = 0
    quiet=False

    def parse_update():
        Progress.current_q+=1
        Progress.current_action = f" parsing Q{Progress.current_q}"

    def export_update(service):
        Progress.current_q+=1
        Progress.current_action = f" exporting Q{Progress.current_q} to {service}"

    def reset():
        Progress.current_q = 0
        Progress.current_action = ""

# prints warning message but doesn't exit program
def warning(msg, show_progress=True):
    Progress.warn_count+=1
    progress = Progress.current_action
    if not show_progress:
        progress = ""
    msg = msg.replace("\n", "\n"+" "*len(progress.strip()+"() ")+"\t"+" "*len("Warning: ")) # adds whitespace
    my_print(f"{Fore.BLUE}({progress.strip()}) \tWarning: {msg}\n{Fore.RESET}")

def my_print(x="", **kwargs):
    if Progress.quiet:
        return
    
    print(x, **kwargs)

# prints msg and then gets user input. returns True if their input is in yes and False if it's in no
# match_case means matching is case sensitive
# ensure this matches function at top of main !!
def get_user_input(msg, yes, no, match_case=False):
    def _lower(s): 
        if match_case:
            return s 
        else:
            return s.lower()
        
    # deal with string input
    if type(yes)==str:
        yes = [yes]
    if type(no)==str:
        no = [no]

    yes = [_lower(s) for s in yes]
    no = [_lower(n) for n in no]

    while True:
        user_in = _lower(input(f"{msg}\nEnter {yes[0]} or {no[0]} > "))
        if user_in in yes:
            return True
        if user_in in no:
            return False
        print("\nInvalid input.\n")


###########
## FILES ##
###########
def TMP_DIR():
    return "program/temporary_directory_which_will_be_deleted!!!!!!!!/"

# creates directory TMP_DIR() if it doesn't exist
def mk_tmp_dir():
    if not os.path.exists(TMP_DIR()):
        os.mkdir(TMP_DIR())

def del_tmp_dir():
    if os.path.exists(TMP_DIR()):
        rmtree(TMP_DIR())

# defaults copy all output files to vm shared dir
# def file_copy(clear_output=False, current=None, new="C:\Users\lewis\Documents\vm\shared"):
#     if clear_output:
#         assert new=="C:\Users\lewis\Documents\vm\shared"
#         for f in os.listdir(new):
#             try:
#                 os.remove(new+"/"+f)
#             except:
#                 pass

#     if current==None:
#         to_copy = ["output/"+str(f) for f in os.listdir("output/") if ("." in f)]
#     else:
#         to_copy=[current]

#     for fpath in to_copy:
#         copy(fpath, new)

# open() with error checking
def safe_open(fpath, m, encoding=None):
    if m=="r" and not os.path.exists(fpath):
        extra = ""
        if not "." in os.path.basename(fpath):
            extra += "\nNo file extension specified."

        cur_dur = os.getcwd() if os.path.dirname(fpath)=='' else os.path.dirname(fpath)
        if os.path.exists(cur_dur) and most_similar(fpath, os.listdir(cur_dur)): 
                extra+=f"\nDid you mean '{os.path.join(os.path.dirname(fpath), most_similar(fpath, os.listdir(cur_dur)))}'?"

        error(f"Provided input filepath ({fpath}) does not exist.{extra}")
    try:
        if encoding:
            return open(fpath, m, encoding=encoding)
        else:
            return open(fpath, m)
    except:
        error(f"Could not open/write file '{fpath}'")

# change file type of filepath
def change_ftype(fpath, newtype):
    return os.path.splitext(fpath)[0]+"."+newtype.replace(".", "")

# moves files to the shared vm folder for testing
def to_vm(from_dir, dice=True):
    import shutil
    if dice:
        to_dir = "C:/Users/lewis/Documents/vm/shared"
    else:
        error("Add windows fpath")
    for fpath in os.listdir(from_dir):
        shutil.copy(os.path.join(from_dir, fpath), to_dir)

# checks if Pandoc is installed, if not asks user if they want to install it. ends termination if Pandoc not installed.
def ensure_pandoc_installed():
    def check():
        try:
            subprocess.run('pandoc --version', check=True, capture_output=True, shell=True)
            return True
        except:
            # error since pandoc not found
            return False      

    # check if normal pandoc installed
    if check(): return

    # check if local pandoc installed
    PPATH = "program/pandoc/pandoc.exe"
    env_value = f"{os.path.dirname(os.path.abspath(PPATH))};{os.environ.get('PATH', '')}"
    if os.path.exists(PPATH):
        # os.environ.setdefault('PYPANDOC_PANDOC', PPATH)
        os.environ["PATH"] = env_value
        if check(): return
        
    # no pandoc found
    do_download = "download pandoc"
    user_in = input(f"No Pandoc installation found. Enter '{do_download}' to install Pandoc in program directory.\n> ")
    if user_in in [do_download, f"'{do_download}'"]:
        print("Downloading and installing Pandoc. This may quite a few minutes.")
        pypandoc.download_pandoc(targetfolder=os.path.join(os.getcwd(), "program/pandoc"), delete_installer=True) # abs path required on linux
        os.environ["PATH"] = env_value
        if not check(): raise Exception("Something went wrong installing Pandoc.")
    else:
        print("\nPandoc required. Download from URL below and ensure 'pandoc' added to PATH.")
        print("https://pandoc.org/installing.html")
        exit()

# called when there isn't a space after # or - or X. when there should be
# asks user if they want program to fix this
# fixes if neccessary, ends termination regardless
def     not_enough_spaces(line):
    ## INFORM USER OF MISTAKE, ASK WHAT THEY WANT TO DO ##
    bullet = ""
    if line[0] in ["#", "-"]:
        bullet = line[0]
    elif re.match("[0-9]+\.", line):
        bullet = line.split(".")[0]+"."
    else:
        Exception("This shouldn't be reached. Line: "+str(line))
    print(f"{Fore.RED}\nSpace missing after '{bullet}' in line '{line}'. There may be more similar errors.{Fore.RESET}")
    assert Progress.import_file
    print(f"Do you want to add spaces where required in {Progress.import_file}?")    
    while True:
        ans = input("Type yes or no > ")
        if ans=="yes":
            print() # terminal newline
            break
        if ans=="no":
            print("Ending termination.")
            exit()
        print("Invalid response.")
    
    ## USER ASKED FOR PROGRAM TO FIX FILE ##
    # get file contents
    with safe_open(Progress.import_fpath, "r") as f:
        raw_contents = f.read()
    
    total_changes = 0
    # first line edge case
    if raw_contents[0]=="#" and raw_contents[1]!=" ":
        total_changes+=1
        print("Changing '#' to '# ' at start of file.")
        raw_contents = "# " + raw_contents[1:] # add space after first #
    
    # standard replacements
    for b in ["(#)", "(-)", "([0-9]+\.)"]:
        pattern = "\n" + b + "([^ ])" # newline precedes bullet, space does not
        match_count = len(re.findall(pattern, raw_contents))
        s = "" if match_count==1 else "s"
        if match_count!=0:
            total_changes+=match_count
            raw_contents = re.sub(pattern, f"\n\\1 \\2", raw_contents)
            pretty_b = b.replace('(', '').replace(')', '').replace('[0-9]+\\', 'X')
            if not Progress.quiet: print(f"Fixed {match_count} incorrect use{s} of '{pretty_b}'.")

    # write to file
    with safe_open(Progress.import_fpath, "w") as f:
        f.write(raw_contents)

    s = "" if total_changes==1 else "s"
    print(f"{Fore.GREEN}Made {total_changes} update{s} to {Progress.import_file}. Try rerunning program.")
    exit()


# called when there are blank lines where there shouldn't be.
# asks user if they want program to fix this
# fixes if neccessary, ends termination regardless
def random_blank_lines():
    assert Progress.import_file
    print(f"\n{Fore.RED}There are blank lines where there shouldn't be any in {Progress.import_file}.{Fore.RESET}")
    print("Do you want the program to fix this?")    
    while True:
        ans = input("Type yes or no > ")
        if ans=="yes":
            print() # terminal newline
            break
        if ans=="no":
            print("Ending termination.")
            exit()
        print("Invalid response.")

    # user wants blank lines to be fixed
    with safe_open(Progress.import_fpath, "r") as f:
        raw_contents = f.read()

    with safe_open(Progress.import_fpath, "w") as f:
        old_len = len(raw_contents)
        updated_contents = re.sub("\n+\n\n", "\n\n", raw_contents.strip("\n"))
        # updated_contents = re.sub("(- .+?)\n\n+(- .+?)[\n|$]", "\\1\n\\2")
        len_diff = old_len - len(updated_contents)
        f.write(updated_contents)


    if len_diff==0:
        print(f"Could not remove any newlines. {Fore.BLUE}Check for empty lines in answers of Q{Progress.current_q}.{Fore.RESET}")
        print(f"To keep the blank line, add a space to show in output, or include {COMMENT} to hide in output.")
        exit()
    else:
        s = "" if len_diff==1 else "s"
        print(f"{Fore.GREEN}Removed {len_diff} newline{s}{Fore.RESET}, but some may have been missed.")
        print("Try rerunning program.\n")
        exit()

